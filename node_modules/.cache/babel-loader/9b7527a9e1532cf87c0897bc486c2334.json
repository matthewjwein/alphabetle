{"ast":null,"code":"import { solution } from './words';\nexport const getDistances = guesses => {\n  const charObj = {};\n  guesses.forEach(word => {\n    word.split('').forEach((letter, i) => {\n      const correctLetterPos = solution[i].charCodeAt(0) - 65;\n      const guessedLetterPos = letter.charCodeAt(0) - 65;\n      const delta = guessedLetterPos - correctLetterPos;\n      return charObj[letter] = delta;\n    });\n  });\n  return charObj;\n};\nexport const getGuessDistances = guess => {\n  const splitSolution = solution.split('');\n  const splitGuess = guess.split('');\n  const solutionCharsTaken = splitSolution.map(_ => false);\n  const statuses = Array.from(Array(guess.length)); // handle all correct cases first\n\n  splitGuess.forEach((letter, i) => {\n    const correctLetterPos = splitSolution[i].charCodeAt(0) - 65;\n    const guessedLetterPos = letter.charCodeAt(0) - 65;\n    statuses[i] = guessedLetterPos - correctLetterPos;\n\n    if (letter === splitSolution[i]) {\n      statuses[i] = 0;\n      solutionCharsTaken[i] = true;\n      return;\n    }\n  });\n  splitGuess.forEach((letter, i) => {\n    if (statuses[i]) return;\n\n    if (!splitSolution.includes(letter)) {\n      // handles the absent case\n      statuses[i] = 'absent';\n      return;\n    } // now we are left with \"present\"s\n\n\n    const indexOfPresentChar = splitSolution.findIndex((x, index) => x === letter && !solutionCharsTaken[index]);\n\n    if (indexOfPresentChar > -1) {\n      statuses[i] = 'present';\n      solutionCharsTaken[indexOfPresentChar] = true;\n      return;\n    } else {\n      statuses[i] = 'absent';\n      return;\n    }\n  });\n  return statuses;\n};","map":{"version":3,"sources":["/Users/matthewwein/Desktop/Game/react-wordle/src/lib/statuses.ts"],"names":["solution","getDistances","guesses","charObj","forEach","word","split","letter","i","correctLetterPos","charCodeAt","guessedLetterPos","delta","getGuessDistances","guess","splitSolution","splitGuess","solutionCharsTaken","map","_","statuses","Array","from","length","includes","indexOfPresentChar","findIndex","x","index"],"mappings":"AAAA,SAASA,QAAT,QAAyB,SAAzB;AAEA,OAAO,MAAMC,YAAY,GACvBC,OAD0B,IAEI;AAC9B,QAAMC,OAAkC,GAAG,EAA3C;AAEAD,EAAAA,OAAO,CAACE,OAAR,CAAiBC,IAAD,IAAU;AACxBA,IAAAA,IAAI,CAACC,KAAL,CAAW,EAAX,EAAeF,OAAf,CAAuB,CAACG,MAAD,EAASC,CAAT,KAAe;AACpC,YAAMC,gBAAgB,GAAGT,QAAQ,CAACQ,CAAD,CAAR,CAAYE,UAAZ,CAAuB,CAAvB,IAA4B,EAArD;AACA,YAAMC,gBAAgB,GAAGJ,MAAM,CAACG,UAAP,CAAkB,CAAlB,IAAuB,EAAhD;AAEA,YAAME,KAAK,GAAGD,gBAAgB,GAAGF,gBAAjC;AAEA,aAAQN,OAAO,CAACI,MAAD,CAAP,GAAkBK,KAA1B;AACD,KAPD;AAQD,GATD;AAWA,SAAOT,OAAP;AACD,CAjBM;AAmBP,OAAO,MAAMU,iBAAiB,GAAIC,KAAD,IAA6B;AAC5D,QAAMC,aAAa,GAAGf,QAAQ,CAACM,KAAT,CAAe,EAAf,CAAtB;AACA,QAAMU,UAAU,GAAGF,KAAK,CAACR,KAAN,CAAY,EAAZ,CAAnB;AAEA,QAAMW,kBAAkB,GAAGF,aAAa,CAACG,GAAd,CAAmBC,CAAD,IAAO,KAAzB,CAA3B;AAEA,QAAMC,QAAkB,GAAGC,KAAK,CAACC,IAAN,CAAWD,KAAK,CAACP,KAAK,CAACS,MAAP,CAAhB,CAA3B,CAN4D,CAQ5D;;AACAP,EAAAA,UAAU,CAACZ,OAAX,CAAmB,CAACG,MAAD,EAASC,CAAT,KAAe;AAChC,UAAMC,gBAAgB,GAAGM,aAAa,CAACP,CAAD,CAAb,CAAiBE,UAAjB,CAA4B,CAA5B,IAAiC,EAA1D;AACA,UAAMC,gBAAgB,GAAGJ,MAAM,CAACG,UAAP,CAAkB,CAAlB,IAAuB,EAAhD;AACAU,IAAAA,QAAQ,CAACZ,CAAD,CAAR,GAAcG,gBAAgB,GAAGF,gBAAjC;;AAEA,QAAIF,MAAM,KAAKQ,aAAa,CAACP,CAAD,CAA5B,EAAiC;AAC/BY,MAAAA,QAAQ,CAACZ,CAAD,CAAR,GAAc,CAAd;AACAS,MAAAA,kBAAkB,CAACT,CAAD,CAAlB,GAAwB,IAAxB;AACA;AACD;AACF,GAVD;AAYAQ,EAAAA,UAAU,CAACZ,OAAX,CAAmB,CAACG,MAAD,EAASC,CAAT,KAAe;AAChC,QAAIY,QAAQ,CAACZ,CAAD,CAAZ,EAAiB;;AAEjB,QAAI,CAACO,aAAa,CAACS,QAAd,CAAuBjB,MAAvB,CAAL,EAAqC;AACnC;AACAa,MAAAA,QAAQ,CAACZ,CAAD,CAAR,GAAc,QAAd;AACA;AACD,KAP+B,CAShC;;;AACA,UAAMiB,kBAAkB,GAAGV,aAAa,CAACW,SAAd,CACzB,CAACC,CAAD,EAAIC,KAAJ,KAAcD,CAAC,KAAKpB,MAAN,IAAgB,CAACU,kBAAkB,CAACW,KAAD,CADxB,CAA3B;;AAIA,QAAIH,kBAAkB,GAAG,CAAC,CAA1B,EAA6B;AAC3BL,MAAAA,QAAQ,CAACZ,CAAD,CAAR,GAAc,SAAd;AACAS,MAAAA,kBAAkB,CAACQ,kBAAD,CAAlB,GAAyC,IAAzC;AACA;AACD,KAJD,MAIO;AACLL,MAAAA,QAAQ,CAACZ,CAAD,CAAR,GAAc,QAAd;AACA;AACD;AACF,GAtBD;AAwBA,SAAOY,QAAP;AACD,CA9CM","sourcesContent":["import { solution } from './words'\n\nexport const getDistances = (\n  guesses: string[]\n): { [key: string]: number } => {\n  const charObj: { [key: string]: number } = {}\n\n  guesses.forEach((word) => {\n    word.split('').forEach((letter, i) => {\n      const correctLetterPos = solution[i].charCodeAt(0) - 65\n      const guessedLetterPos = letter.charCodeAt(0) - 65\n\n      const delta = guessedLetterPos - correctLetterPos\n\n      return (charObj[letter] = delta)\n    })\n  })\n\n  return charObj\n}\n\nexport const getGuessDistances = (guess: string): number[] => {\n  const splitSolution = solution.split('')\n  const splitGuess = guess.split('')\n\n  const solutionCharsTaken = splitSolution.map((_) => false)\n\n  const statuses: number[] = Array.from(Array(guess.length))\n\n  // handle all correct cases first\n  splitGuess.forEach((letter, i) => {\n    const correctLetterPos = splitSolution[i].charCodeAt(0) - 65\n    const guessedLetterPos = letter.charCodeAt(0) - 65\n    statuses[i] = guessedLetterPos - correctLetterPos\n\n    if (letter === splitSolution[i]) {\n      statuses[i] = 0\n      solutionCharsTaken[i] = true\n      return\n    }\n  })\n\n  splitGuess.forEach((letter, i) => {\n    if (statuses[i]) return\n\n    if (!splitSolution.includes(letter)) {\n      // handles the absent case\n      statuses[i] = 'absent'\n      return\n    }\n\n    // now we are left with \"present\"s\n    const indexOfPresentChar = splitSolution.findIndex(\n      (x, index) => x === letter && !solutionCharsTaken[index]\n    )\n\n    if (indexOfPresentChar > -1) {\n      statuses[i] = 'present'\n      solutionCharsTaken[indexOfPresentChar] = true\n      return\n    } else {\n      statuses[i] = 'absent'\n      return\n    }\n  })\n\n  return statuses\n}\n"]},"metadata":{},"sourceType":"module"}