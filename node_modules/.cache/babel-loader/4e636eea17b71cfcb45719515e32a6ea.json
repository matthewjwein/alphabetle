{"ast":null,"code":"import { WORDS } from '../constants/wordlist';\nimport { VALID_GUESSES } from '../constants/validGuesses';\nexport const isWordInWordList = word => {\n  return WORDS.includes(word.toLowerCase()) || VALID_GUESSES.includes(word.toLowerCase());\n};\nexport const isWinningWord = word => {\n  return solution === word;\n}; // build a set of previously revealed letters - present and correct\n// guess must use correct letters in that space and any other revealed letters\n\nexport const findFirstUnusedReveal = (word, guesses) => {\n  const knownLetterSet = new Set();\n\n  for (const guess of guesses) {\n    const statuses = getGuessStatuses(guess);\n\n    for (let i = 0; i < guess.length; i++) {\n      if (statuses[i] === 'correct' || statuses[i] === 'present') {\n        knownLetterSet.add(guess[i]);\n      }\n\n      if (statuses[i] === 'correct' && word[i] !== guess[i]) {\n        return `Must use ${guess[i]} in position ${i + 1}`;\n      }\n    }\n  }\n\n  for (const letter of Array.from(knownLetterSet.values())) {\n    // fail fast, always return first failed letter if applicable\n    if (!word.includes(letter)) {\n      return `Guess must contain ${letter}`;\n    }\n  }\n\n  return false;\n};\nexport const getWordOfDay = () => {\n  // January 1, 2022 Game Epoch\n  const epochMs = new Date('January 1, 2022 00:00:00').valueOf();\n  const now = Date.now();\n  const msInDay = 86400000;\n  const index = Math.floor((now - epochMs) / msInDay);\n  const nextday = (index + 1) * msInDay + epochMs;\n  return {\n    solution: WORDS[index % WORDS.length].toUpperCase(),\n    solutionIndex: index,\n    tomorrow: nextday\n  };\n};\nexport const {\n  solution,\n  solutionIndex,\n  tomorrow\n} = getWordOfDay();","map":{"version":3,"sources":["/Users/matthewwein/Desktop/Game/react-wordle/src/lib/words.ts"],"names":["WORDS","VALID_GUESSES","isWordInWordList","word","includes","toLowerCase","isWinningWord","solution","findFirstUnusedReveal","guesses","knownLetterSet","Set","guess","statuses","getGuessStatuses","i","length","add","letter","Array","from","values","getWordOfDay","epochMs","Date","valueOf","now","msInDay","index","Math","floor","nextday","toUpperCase","solutionIndex","tomorrow"],"mappings":"AAAA,SAASA,KAAT,QAAsB,uBAAtB;AACA,SAASC,aAAT,QAA8B,2BAA9B;AAGA,OAAO,MAAMC,gBAAgB,GAAIC,IAAD,IAAkB;AAChD,SACEH,KAAK,CAACI,QAAN,CAAeD,IAAI,CAACE,WAAL,EAAf,KACAJ,aAAa,CAACG,QAAd,CAAuBD,IAAI,CAACE,WAAL,EAAvB,CAFF;AAID,CALM;AAOP,OAAO,MAAMC,aAAa,GAAIH,IAAD,IAAkB;AAC7C,SAAOI,QAAQ,KAAKJ,IAApB;AACD,CAFM,C,CAIP;AACA;;AACA,OAAO,MAAMK,qBAAqB,GAAG,CAACL,IAAD,EAAeM,OAAf,KAAqC;AACxE,QAAMC,cAAc,GAAG,IAAIC,GAAJ,EAAvB;;AACA,OAAK,MAAMC,KAAX,IAAoBH,OAApB,EAA6B;AAC3B,UAAMI,QAAQ,GAAGC,gBAAgB,CAACF,KAAD,CAAjC;;AAEA,SAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,KAAK,CAACI,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AACrC,UAAIF,QAAQ,CAACE,CAAD,CAAR,KAAgB,SAAhB,IAA6BF,QAAQ,CAACE,CAAD,CAAR,KAAgB,SAAjD,EAA4D;AAC1DL,QAAAA,cAAc,CAACO,GAAf,CAAmBL,KAAK,CAACG,CAAD,CAAxB;AACD;;AACD,UAAIF,QAAQ,CAACE,CAAD,CAAR,KAAgB,SAAhB,IAA6BZ,IAAI,CAACY,CAAD,CAAJ,KAAYH,KAAK,CAACG,CAAD,CAAlD,EAAuD;AACrD,eAAQ,YAAWH,KAAK,CAACG,CAAD,CAAI,gBAAeA,CAAC,GAAG,CAAE,EAAjD;AACD;AACF;AACF;;AAED,OAAK,MAAMG,MAAX,IAAqBC,KAAK,CAACC,IAAN,CAAWV,cAAc,CAACW,MAAf,EAAX,CAArB,EAA0D;AACxD;AACA,QAAI,CAAClB,IAAI,CAACC,QAAL,CAAcc,MAAd,CAAL,EAA4B;AAC1B,aAAQ,sBAAqBA,MAAO,EAApC;AACD;AACF;;AACD,SAAO,KAAP;AACD,CAtBM;AAwBP,OAAO,MAAMI,YAAY,GAAG,MAAM;AAChC;AACA,QAAMC,OAAO,GAAG,IAAIC,IAAJ,CAAS,0BAAT,EAAqCC,OAArC,EAAhB;AACA,QAAMC,GAAG,GAAGF,IAAI,CAACE,GAAL,EAAZ;AACA,QAAMC,OAAO,GAAG,QAAhB;AACA,QAAMC,KAAK,GAAGC,IAAI,CAACC,KAAL,CAAW,CAACJ,GAAG,GAAGH,OAAP,IAAkBI,OAA7B,CAAd;AACA,QAAMI,OAAO,GAAG,CAACH,KAAK,GAAG,CAAT,IAAcD,OAAd,GAAwBJ,OAAxC;AAEA,SAAO;AACLhB,IAAAA,QAAQ,EAAEP,KAAK,CAAC4B,KAAK,GAAG5B,KAAK,CAACgB,MAAf,CAAL,CAA4BgB,WAA5B,EADL;AAELC,IAAAA,aAAa,EAAEL,KAFV;AAGLM,IAAAA,QAAQ,EAAEH;AAHL,GAAP;AAKD,CAbM;AAeP,OAAO,MAAM;AAAExB,EAAAA,QAAF;AAAY0B,EAAAA,aAAZ;AAA2BC,EAAAA;AAA3B,IAAwCZ,YAAY,EAA1D","sourcesContent":["import { WORDS } from '../constants/wordlist'\nimport { VALID_GUESSES } from '../constants/validGuesses'\nimport { getGuessDistances } from './statuses'\n\nexport const isWordInWordList = (word: string) => {\n  return (\n    WORDS.includes(word.toLowerCase()) ||\n    VALID_GUESSES.includes(word.toLowerCase())\n  )\n}\n\nexport const isWinningWord = (word: string) => {\n  return solution === word\n}\n\n// build a set of previously revealed letters - present and correct\n// guess must use correct letters in that space and any other revealed letters\nexport const findFirstUnusedReveal = (word: string, guesses: string[]) => {\n  const knownLetterSet = new Set<string>()\n  for (const guess of guesses) {\n    const statuses = getGuessStatuses(guess)\n\n    for (let i = 0; i < guess.length; i++) {\n      if (statuses[i] === 'correct' || statuses[i] === 'present') {\n        knownLetterSet.add(guess[i])\n      }\n      if (statuses[i] === 'correct' && word[i] !== guess[i]) {\n        return `Must use ${guess[i]} in position ${i + 1}`\n      }\n    }\n  }\n\n  for (const letter of Array.from(knownLetterSet.values())) {\n    // fail fast, always return first failed letter if applicable\n    if (!word.includes(letter)) {\n      return `Guess must contain ${letter}`\n    }\n  }\n  return false\n}\n\nexport const getWordOfDay = () => {\n  // January 1, 2022 Game Epoch\n  const epochMs = new Date('January 1, 2022 00:00:00').valueOf()\n  const now = Date.now()\n  const msInDay = 86400000\n  const index = Math.floor((now - epochMs) / msInDay)\n  const nextday = (index + 1) * msInDay + epochMs\n\n  return {\n    solution: WORDS[index % WORDS.length].toUpperCase(),\n    solutionIndex: index,\n    tomorrow: nextday,\n  }\n}\n\nexport const { solution, solutionIndex, tomorrow } = getWordOfDay()\n"]},"metadata":{},"sourceType":"module"}